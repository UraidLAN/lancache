server_name lancache-epicgames; # primary - used in proxy_cache_key

# Domains we are caching content from
server_name download.epicgames.com
            epicgames-download1.akamaized.net
            fortnitecontent-website-prod07.ol.epicgames.com;

location / {
    # Load settings to proxy and cache this upstream location
    include includes/proxy-cache-upstream.conf;

    # Cache data in the cache named "epicgames" 
    proxy_cache epicgames;

    ########## Proxy settings specific to this upstream location ##########

    # Battle.net downloader performs many range requests on large files,
    # and the range requests may be different each time a game is downloaded
    # so we must request and cache consistent slices of the files using our
    # own range requests, and then serve the ranges requested by the Battle.net
    # downloader
    # See here for more info on Nginx's behaviour with Slice:
    # https://www.nginx.com/blog/smart-efficient-byte-range-caching-nginx/#cache-slice

    # Set slice range to 1 megabyte to give good interactivity
    slice 1m;

    # Set upstream request headers to include a range request for the slice we want

    # Cache based on URI, without query string, and with slice range
    proxy_cache_key "$server_name$uri";

    # Honour "Pragma:no-cache" (HTTP/1.0) and "Cache-Control:no-cache"(HTTP/1.1)
    # request from Battle.net downloader, which will mean if a cached file
    # is found to be corrupt, the Battle.net downloader will request
    # a fresh copy from upstream, which Nginx will cache
    proxy_cache_bypass $http_pragma;
    proxy_cache_bypass $http_cache_control;
    
    # The various CDNs that Blizzard use each employ a different ETag scheme
    # resulting in different ETags for the same piece of (non-modified) content
    # As a result our cached ETag may not match the client's requested ETag
    # even if the content has not been modified
    # To avoid this, we don't pass through the ETag header to clients at all
    proxy_hide_header ETag;
}
